// trying to do aoc 2024 day 1 in jayko


// important probably for typecasting later
fn a2i(a: char ) -> i32 {
    if a == '0' {return 0;}
    if a == '1' {return 1;}
    if a == '2' {return 2;}
    if a == '3' {return 3;}
    if a == '4' {return 4;}
    if a == '5' {return 5;}
    if a == '6' {return 6;}
    if a == '7' {return 7;}
    if a == '8' {return 8;}
    if a == '9' {return 9;}
}

fn accumulate_integer(input: str) -> i32 {
     
}

// what is the return type of the readlines function? maybe void?
fn read_lines(input: str) -> str {
    return 0;
}


fn main() -> i32 {
    // because the source is run from where run the compiled binary from
    // we have to put a significant part of the path in there.
    let puzzle_input: str = read_file("jko_src/jko_aoc/day1/day1p1input.txt");
    let i: i32 = 0;         // loop iterator for full file
    let j: i32 = 0;         // loop iterator for a single line
    let ch: char  = '\0';

    let left: i32[] = [];       // an array of integers that form the puzzle input
    let right: i32[] = [];      // an array of integers on the right that form the puzzle input

    let line: char[] = [];
    let tmp_left: char[] = [];  // temp accumulators for the string on each side
    let tmp_right: char[] = [];


    //let testchar: char = '0';
    //say (10 + a2i(testchar));

    //say puzzle_input;               // can print the file out but isn't too useful
    // we need something like readlines, so lets break the input stream into lines
    // how do we get just read_lines
    loop puzzle_input[i] != '\0' {
        if puzzle_input[i] != '\n' {
            // lets hard code it by index maybe
            // 0,1,2 ,3 ,4, is the left
            // 8,9,10,11,12 is the right
            line.append(puzzle_input[i]);
            
            //ch = puzzle_input[i]; 
            //say ch;


        } else if puzzle_input[i] == '\n' {
            // \n denotes the end of aline
            loop j < line.length() { 
                let c: char = line[j]; 
                say c;
                j = j+1;
            }
            say "j is = "; say j; say "\n";
            say " <- LINEBREAK\n";
            // reset all the counters
        }
        line = [];
        i=i+1;
    }
    return 0;
}
